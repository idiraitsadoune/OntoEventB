/*
 * generated by Xtext 2.25.0
 */
package fr.cs.ontoeventb.pivotmodel.serializer;

import com.google.inject.Inject;
import fr.cs.ontoeventb.pivotmodel.services.DSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import pivotmodel.CardinalityClass;
import pivotmodel.CaseOfClass;
import pivotmodel.ClassType;
import pivotmodel.CollectionType;
import pivotmodel.ComplementClass;
import pivotmodel.ConditionProperty;
import pivotmodel.ContextDependentUnit;
import pivotmodel.ConversionBasedUnit;
import pivotmodel.CurrencyType;
import pivotmodel.DependentProperty;
import pivotmodel.DerivedUnit;
import pivotmodel.DerivedUnitElement;
import pivotmodel.EnumeratedClass;
import pivotmodel.EnumeratedType;
import pivotmodel.ExistantialClass;
import pivotmodel.HasValueClass;
import pivotmodel.IntersectionClass;
import pivotmodel.MaxCardinalityClass;
import pivotmodel.MeasureType;
import pivotmodel.MinCardinalityClass;
import pivotmodel.NamedUnit;
import pivotmodel.NonStandardUnit;
import pivotmodel.NotNumericType;
import pivotmodel.NumberEnumeratedType;
import pivotmodel.NumericType;
import pivotmodel.Ontology;
import pivotmodel.PivotmodelPackage;
import pivotmodel.SimpleClass;
import pivotmodel.SimpleProperty;
import pivotmodel.SingleValue;
import pivotmodel.StandardUnit;
import pivotmodel.UnionClass;
import pivotmodel.UniversalClass;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PivotmodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PivotmodelPackage.CARDINALITY_CLASS:
				sequence_CardinalityClass(context, (CardinalityClass) semanticObject); 
				return; 
			case PivotmodelPackage.CASE_OF_CLASS:
				sequence_CaseOfClass(context, (CaseOfClass) semanticObject); 
				return; 
			case PivotmodelPackage.CLASS_TYPE:
				sequence_ClassType(context, (ClassType) semanticObject); 
				return; 
			case PivotmodelPackage.COLLECTION_TYPE:
				sequence_CollectionType(context, (CollectionType) semanticObject); 
				return; 
			case PivotmodelPackage.COMPLEMENT_CLASS:
				sequence_ComplementClass(context, (ComplementClass) semanticObject); 
				return; 
			case PivotmodelPackage.CONDITION_PROPERTY:
				sequence_ConditionProperty(context, (ConditionProperty) semanticObject); 
				return; 
			case PivotmodelPackage.CONTEXT_DEPENDENT_UNIT:
				sequence_ContextDependentUnit(context, (ContextDependentUnit) semanticObject); 
				return; 
			case PivotmodelPackage.CONVERSION_BASED_UNIT:
				sequence_ConversionBasedUnit(context, (ConversionBasedUnit) semanticObject); 
				return; 
			case PivotmodelPackage.CURRENCY_TYPE:
				sequence_CurrencyType(context, (CurrencyType) semanticObject); 
				return; 
			case PivotmodelPackage.DEPENDENT_PROPERTY:
				sequence_DependentProperty(context, (DependentProperty) semanticObject); 
				return; 
			case PivotmodelPackage.DERIVED_UNIT:
				sequence_DerivedUnit(context, (DerivedUnit) semanticObject); 
				return; 
			case PivotmodelPackage.DERIVED_UNIT_ELEMENT:
				sequence_DerivedUnitElement(context, (DerivedUnitElement) semanticObject); 
				return; 
			case PivotmodelPackage.ENUMERATED_CLASS:
				sequence_EnumeratedClass(context, (EnumeratedClass) semanticObject); 
				return; 
			case PivotmodelPackage.ENUMERATED_TYPE:
				sequence_EnumeratedType(context, (EnumeratedType) semanticObject); 
				return; 
			case PivotmodelPackage.EXISTANTIAL_CLASS:
				sequence_ExistantialClass(context, (ExistantialClass) semanticObject); 
				return; 
			case PivotmodelPackage.HAS_VALUE_CLASS:
				sequence_HasValueClass(context, (HasValueClass) semanticObject); 
				return; 
			case PivotmodelPackage.INTERSECTION_CLASS:
				sequence_IntersectionClass(context, (IntersectionClass) semanticObject); 
				return; 
			case PivotmodelPackage.MAX_CARDINALITY_CLASS:
				sequence_MaxCardinalityClass(context, (MaxCardinalityClass) semanticObject); 
				return; 
			case PivotmodelPackage.MEASURE_TYPE:
				sequence_MeasureType(context, (MeasureType) semanticObject); 
				return; 
			case PivotmodelPackage.MIN_CARDINALITY_CLASS:
				sequence_MinCardinalityClass(context, (MinCardinalityClass) semanticObject); 
				return; 
			case PivotmodelPackage.NAMED_UNIT:
				sequence_NamedUnit_Impl(context, (NamedUnit) semanticObject); 
				return; 
			case PivotmodelPackage.NON_STANDARD_UNIT:
				sequence_NonStandardUnit(context, (NonStandardUnit) semanticObject); 
				return; 
			case PivotmodelPackage.NOT_NUMERIC_TYPE:
				sequence_NotNumericType(context, (NotNumericType) semanticObject); 
				return; 
			case PivotmodelPackage.NUMBER_ENUMERATED_TYPE:
				sequence_NumberEnumeratedType(context, (NumberEnumeratedType) semanticObject); 
				return; 
			case PivotmodelPackage.NUMERIC_TYPE:
				sequence_NumericType_Impl(context, (NumericType) semanticObject); 
				return; 
			case PivotmodelPackage.ONTOLOGY:
				sequence_Ontology(context, (Ontology) semanticObject); 
				return; 
			case PivotmodelPackage.SIMPLE_CLASS:
				sequence_SimpleClass(context, (SimpleClass) semanticObject); 
				return; 
			case PivotmodelPackage.SIMPLE_PROPERTY:
				sequence_SimpleProperty(context, (SimpleProperty) semanticObject); 
				return; 
			case PivotmodelPackage.SINGLE_VALUE:
				sequence_SingleValue(context, (SingleValue) semanticObject); 
				return; 
			case PivotmodelPackage.STANDARD_UNIT:
				sequence_StandardUnit(context, (StandardUnit) semanticObject); 
				return; 
			case PivotmodelPackage.UNION_CLASS:
				sequence_UnionClass(context, (UnionClass) semanticObject); 
				return; 
			case PivotmodelPackage.UNIVERSAL_CLASS:
				sequence_UniversalClass(context, (UniversalClass) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ClassDefinition returns CardinalityClass
	 *     CardinalityClass returns CardinalityClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         card=EInt 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString]
	 *     )
	 */
	protected void sequence_CardinalityClass(ISerializationContext context, CardinalityClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns CaseOfClass
	 *     CaseOfClass returns CaseOfClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         caseOf+=[ClassDefinition|EString] 
	 *         caseOf+=[ClassDefinition|EString]* 
	 *         (importedProperties+=[PropertyDefinition|EString] importedProperties+=[PropertyDefinition|EString]*)?
	 *     )
	 */
	protected void sequence_CaseOfClass(ISerializationContext context, CaseOfClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns ClassType
	 *     ClassType returns ClassType
	 *
	 * Constraint:
	 *     (name=EString basedOn=[ClassDefinition|EString])
	 */
	protected void sequence_ClassType(ISerializationContext context, ClassType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.CLASS_TYPE__BASED_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.CLASS_TYPE__BASED_ON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getClassTypeAccess().getBasedOnClassDefinitionEStringParserRuleCall_4_0_1(), semanticObject.eGet(PivotmodelPackage.Literals.CLASS_TYPE__BASED_ON, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns CollectionType
	 *     CollectionType returns CollectionType
	 *
	 * Constraint:
	 *     (name=EString is=PredefinedCollection collectionOf=[DataTypeDefinition|EString])
	 */
	protected void sequence_CollectionType(ISerializationContext context, CollectionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.COLLECTION_TYPE__IS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.COLLECTION_TYPE__IS));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.COLLECTION_TYPE__COLLECTION_OF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.COLLECTION_TYPE__COLLECTION_OF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCollectionTypeAccess().getIsPredefinedCollectionEnumRuleCall_4_0(), semanticObject.getIs());
		feeder.accept(grammarAccess.getCollectionTypeAccess().getCollectionOfDataTypeDefinitionEStringParserRuleCall_6_0_1(), semanticObject.eGet(PivotmodelPackage.Literals.COLLECTION_TYPE__COLLECTION_OF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns ComplementClass
	 *     ComplementClass returns ComplementClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         combinationOf+=[ClassDefinition|EString] 
	 *         combinationOf+=[ClassDefinition|EString]*
	 *     )
	 */
	protected void sequence_ComplementClass(ISerializationContext context, ComplementClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyDefinition returns ConditionProperty
	 *     ConditionProperty returns ConditionProperty
	 *
	 * Constraint:
	 *     (
	 *         isFunctional?='isFunctional'? 
	 *         isSymmetric?='isSymmetric'? 
	 *         isTransitive?='isTransitive'? 
	 *         isInverseFunctional?='isInverseFunctional'? 
	 *         name=EString 
	 *         range=[DataTypeDefinition|EString]? 
	 *         (subPropertyOf+=[PropertyDefinition|EString] subPropertyOf+=[PropertyDefinition|EString]*)? 
	 *         (equivalentTo+=[PropertyDefinition|EString] equivalentTo+=[PropertyDefinition|EString]*)? 
	 *         (inverseOf+=[PropertyDefinition|EString] inverseOf+=[PropertyDefinition|EString]*)? 
	 *         domain=[ClassDefinition|EString]?
	 *     )
	 */
	protected void sequence_ConditionProperty(ISerializationContext context, ConditionProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns ContextDependentUnit
	 *     NamedUnit returns ContextDependentUnit
	 *     ContextDependentUnit returns ContextDependentUnit
	 *
	 * Constraint:
	 *     (name=EString exponent=EInt?)
	 */
	protected void sequence_ContextDependentUnit(ISerializationContext context, ContextDependentUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns ConversionBasedUnit
	 *     NamedUnit returns ConversionBasedUnit
	 *     ConversionBasedUnit returns ConversionBasedUnit
	 *
	 * Constraint:
	 *     (name=EString exponent=EInt? valueComponent=EInt unitComponent=[UnitType|EString])
	 */
	protected void sequence_ConversionBasedUnit(ISerializationContext context, ConversionBasedUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns CurrencyType
	 *     CurrencyType returns CurrencyType
	 *
	 * Constraint:
	 *     (name=EString basedOn=PredefinedType currency=PredefinedCurrency)
	 */
	protected void sequence_CurrencyType(ISerializationContext context, CurrencyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.CURRENCY_TYPE__CURRENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.CURRENCY_TYPE__CURRENCY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCurrencyTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCurrencyTypeAccess().getBasedOnPredefinedTypeEnumRuleCall_4_0(), semanticObject.getBasedOn());
		feeder.accept(grammarAccess.getCurrencyTypeAccess().getCurrencyPredefinedCurrencyEnumRuleCall_6_0(), semanticObject.getCurrency());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyDefinition returns DependentProperty
	 *     DependentProperty returns DependentProperty
	 *
	 * Constraint:
	 *     (
	 *         isFunctional?='isFunctional'? 
	 *         isSymmetric?='isSymmetric'? 
	 *         isTransitive?='isTransitive'? 
	 *         isInverseFunctional?='isInverseFunctional'? 
	 *         name=EString 
	 *         range=[DataTypeDefinition|EString]? 
	 *         (subPropertyOf+=[PropertyDefinition|EString] subPropertyOf+=[PropertyDefinition|EString]*)? 
	 *         (equivalentTo+=[PropertyDefinition|EString] equivalentTo+=[PropertyDefinition|EString]*)? 
	 *         (inverseOf+=[PropertyDefinition|EString] inverseOf+=[PropertyDefinition|EString]*)? 
	 *         domain=[ClassDefinition|EString]? 
	 *         dependsOn+=[PropertyDefinition|EString] 
	 *         dependsOn+=[PropertyDefinition|EString]*
	 *     )
	 */
	protected void sequence_DependentProperty(ISerializationContext context, DependentProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DerivedUnitElement returns DerivedUnitElement
	 *
	 * Constraint:
	 *     (name=EString exponent=EInt? unit=[NamedUnit|EString])
	 */
	protected void sequence_DerivedUnitElement(ISerializationContext context, DerivedUnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns DerivedUnit
	 *     DerivedUnit returns DerivedUnit
	 *
	 * Constraint:
	 *     (derivedUnitElement+=DerivedUnitElement derivedUnitElement+=DerivedUnitElement*)
	 */
	protected void sequence_DerivedUnit(ISerializationContext context, DerivedUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns EnumeratedClass
	 *     EnumeratedClass returns EnumeratedClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         oneOf+=[SingleValue|EString] 
	 *         oneOf+=[SingleValue|EString]*
	 *     )
	 */
	protected void sequence_EnumeratedClass(ISerializationContext context, EnumeratedClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns EnumeratedType
	 *     EnumeratedType returns EnumeratedType
	 *
	 * Constraint:
	 *     (name=EString contains+=[SingleValue|EString] contains+=[SingleValue|EString]*)
	 */
	protected void sequence_EnumeratedType(ISerializationContext context, EnumeratedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns ExistantialClass
	 *     ExistantialClass returns ExistantialClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString] 
	 *         toDataDefinition=[DataTypeDefinition|EString]
	 *     )
	 */
	protected void sequence_ExistantialClass(ISerializationContext context, ExistantialClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns HasValueClass
	 *     HasValueClass returns HasValueClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString] 
	 *         toDataDefinition=[DataTypeDefinition|EString]
	 *     )
	 */
	protected void sequence_HasValueClass(ISerializationContext context, HasValueClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns IntersectionClass
	 *     IntersectionClass returns IntersectionClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         combinationOf+=[ClassDefinition|EString] 
	 *         combinationOf+=[ClassDefinition|EString]*
	 *     )
	 */
	protected void sequence_IntersectionClass(ISerializationContext context, IntersectionClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns MaxCardinalityClass
	 *     MaxCardinalityClass returns MaxCardinalityClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         maxCard=EInt 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString]
	 *     )
	 */
	protected void sequence_MaxCardinalityClass(ISerializationContext context, MaxCardinalityClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns MeasureType
	 *     MeasureType returns MeasureType
	 *
	 * Constraint:
	 *     (name=EString basedOn=PredefinedType unit=UnitType)
	 */
	protected void sequence_MeasureType(ISerializationContext context, MeasureType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.MEASURE_TYPE__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.MEASURE_TYPE__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeasureTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMeasureTypeAccess().getBasedOnPredefinedTypeEnumRuleCall_4_0(), semanticObject.getBasedOn());
		feeder.accept(grammarAccess.getMeasureTypeAccess().getUnitUnitTypeParserRuleCall_6_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns MinCardinalityClass
	 *     MinCardinalityClass returns MinCardinalityClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         minCard=EInt 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString]
	 *     )
	 */
	protected void sequence_MinCardinalityClass(ISerializationContext context, MinCardinalityClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns NamedUnit
	 *     NamedUnit returns NamedUnit
	 *     NamedUnit_Impl returns NamedUnit
	 *
	 * Constraint:
	 *     exponent=EInt?
	 */
	protected void sequence_NamedUnit_Impl(ISerializationContext context, NamedUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns NonStandardUnit
	 *     NamedUnit returns NonStandardUnit
	 *     NonStandardUnit returns NonStandardUnit
	 *
	 * Constraint:
	 *     (name=EString exponent=EInt?)
	 */
	protected void sequence_NonStandardUnit(ISerializationContext context, NonStandardUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns NotNumericType
	 *     NotNumericType returns NotNumericType
	 *
	 * Constraint:
	 *     (name=EString basedOn=PredefinedType)
	 */
	protected void sequence_NotNumericType(ISerializationContext context, NotNumericType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotNumericTypeAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNotNumericTypeAccess().getBasedOnPredefinedTypeEnumRuleCall_4_0(), semanticObject.getBasedOn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns NumberEnumeratedType
	 *     NumberEnumeratedType returns NumberEnumeratedType
	 *
	 * Constraint:
	 *     (name=EString contains+=EInt contains+=EInt*)
	 */
	protected void sequence_NumberEnumeratedType(ISerializationContext context, NumberEnumeratedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns NumericType
	 *     NumericType_Impl returns NumericType
	 *
	 * Constraint:
	 *     (name=EString basedOn=PredefinedType)
	 */
	protected void sequence_NumericType_Impl(ISerializationContext context, NumericType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.PRIMITIVE_TYPE__BASED_ON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericType_ImplAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNumericType_ImplAccess().getBasedOnPredefinedTypeEnumRuleCall_4_0(), semanticObject.getBasedOn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ontology returns Ontology
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (containedClasses+=ClassDefinition containedClasses+=ClassDefinition*)? 
	 *         (containedProperties+=PropertyDefinition containedProperties+=PropertyDefinition*)? 
	 *         (containedDataTypes+=DataTypeDefinition containedDataTypes+=DataTypeDefinition*)?
	 *     )
	 */
	protected void sequence_Ontology(ISerializationContext context, Ontology semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns SimpleClass
	 *     SimpleClass returns SimpleClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)?
	 *     )
	 */
	protected void sequence_SimpleClass(ISerializationContext context, SimpleClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyDefinition returns SimpleProperty
	 *     SimpleProperty returns SimpleProperty
	 *
	 * Constraint:
	 *     (
	 *         isFunctional?='isFunctional'? 
	 *         isSymmetric?='isSymmetric'? 
	 *         isTransitive?='isTransitive'? 
	 *         isInverseFunctional?='isInverseFunctional'? 
	 *         name=EString 
	 *         range=[DataTypeDefinition|EString]? 
	 *         (subPropertyOf+=[PropertyDefinition|EString] subPropertyOf+=[PropertyDefinition|EString]*)? 
	 *         (equivalentTo+=[PropertyDefinition|EString] equivalentTo+=[PropertyDefinition|EString]*)? 
	 *         (inverseOf+=[PropertyDefinition|EString] inverseOf+=[PropertyDefinition|EString]*)? 
	 *         domain=[ClassDefinition|EString]?
	 *     )
	 */
	protected void sequence_SimpleProperty(ISerializationContext context, SimpleProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataTypeDefinition returns SingleValue
	 *     SingleValue returns SingleValue
	 *
	 * Constraint:
	 *     (name=EString isOfType=[DataTypeDefinition|EString])
	 */
	protected void sequence_SingleValue(ISerializationContext context, SingleValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.DATA_TYPE_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PivotmodelPackage.Literals.SINGLE_VALUE__IS_OF_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PivotmodelPackage.Literals.SINGLE_VALUE__IS_OF_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleValueAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSingleValueAccess().getIsOfTypeDataTypeDefinitionEStringParserRuleCall_4_0_1(), semanticObject.eGet(PivotmodelPackage.Literals.SINGLE_VALUE__IS_OF_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitType returns StandardUnit
	 *     NamedUnit returns StandardUnit
	 *     StandardUnit returns StandardUnit
	 *
	 * Constraint:
	 *     (exponent=EInt? prefix=PrefixeType? name=UnitName)
	 */
	protected void sequence_StandardUnit(ISerializationContext context, StandardUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns UnionClass
	 *     UnionClass returns UnionClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         combinationOf+=[ClassDefinition|EString] 
	 *         combinationOf+=[ClassDefinition|EString]*
	 *     )
	 */
	protected void sequence_UnionClass(ISerializationContext context, UnionClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassDefinition returns UniversalClass
	 *     UniversalClass returns UniversalClass
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (subClassOf+=[ClassDefinition|EString] subClassOf+=[ClassDefinition|EString]*)? 
	 *         (disjointWith+=[ClassDefinition|EString] disjointWith+=[ClassDefinition|EString]*)? 
	 *         (equivalentTo+=[ClassDefinition|EString] equivalentTo+=[ClassDefinition|EString]*)? 
	 *         (describedBy+=[PropertyDefinition|EString] describedBy+=[PropertyDefinition|EString]*)? 
	 *         onProperty=[PropertyDefinition|EString] 
	 *         toDataDefinition=[DataTypeDefinition|EString]
	 *     )
	 */
	protected void sequence_UniversalClass(ISerializationContext context, UniversalClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
